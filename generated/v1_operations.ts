/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Operations API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  CancelOperationRequest,
  CosmicapisProtoEmpty,
  ListOperationsResponse,
  Operation,
  OperationsListOperationsParams,
  Status
} from './v1_operations.schemas';


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Lists operations that match the specified filter in the request. If the
 server doesn't support this method, it returns `UNIMPLEMENTED`.

 NOTE: the `name` binding allows API services to override the binding
 to use different resource name schemes, such as `users/*\/operations`. To
 override the binding, API services can add a binding such as
 `"/v1/{name=users/*}/operations"` to their service configuration.
 For backwards compatibility, the default name includes the operations
 collection id, however overriding users must ensure the name binding
 is the parent resource, without the operations collection id.
 */
export const operationsListOperations = (
    params?: OperationsListOperationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListOperationsResponse>> => {
    
    
    return axios.get(
      `http://localhost:3333/operations/v1/operations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getOperationsListOperationsQueryKey = (params?: OperationsListOperationsParams,) => {
    return [`http://localhost:3333/operations/v1/operations`, ...(params ? [params]: [])] as const;
    }

    
export const getOperationsListOperationsQueryOptions = <TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(params?: OperationsListOperationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOperationsListOperationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof operationsListOperations>>> = ({ signal }) => operationsListOperations(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OperationsListOperationsQueryResult = NonNullable<Awaited<ReturnType<typeof operationsListOperations>>>
export type OperationsListOperationsQueryError = AxiosError<Status>


export function useOperationsListOperations<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params: undefined |  OperationsListOperationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof operationsListOperations>>,
          TError,
          Awaited<ReturnType<typeof operationsListOperations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsListOperations<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params?: OperationsListOperationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof operationsListOperations>>,
          TError,
          Awaited<ReturnType<typeof operationsListOperations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsListOperations<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params?: OperationsListOperationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOperationsListOperations<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params?: OperationsListOperationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOperationsListOperationsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOperationsListOperationsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(params?: OperationsListOperationsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOperationsListOperationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof operationsListOperations>>> = ({ signal }) => operationsListOperations(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OperationsListOperationsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof operationsListOperations>>>
export type OperationsListOperationsSuspenseQueryError = AxiosError<Status>


export function useOperationsListOperationsSuspense<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params: undefined |  OperationsListOperationsParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsListOperationsSuspense<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params?: OperationsListOperationsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsListOperationsSuspense<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params?: OperationsListOperationsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOperationsListOperationsSuspense<TData = Awaited<ReturnType<typeof operationsListOperations>>, TError = AxiosError<Status>>(
 params?: OperationsListOperationsParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsListOperations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOperationsListOperationsSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the latest state of a long-running operation.  Clients can use this
 method to poll the operation result at intervals as recommended by the API
 service.
 */
export const operationsGetOperation = (
    operation: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Operation>> => {
    
    
    return axios.get(
      `http://localhost:3333/operations/v1/operations/${operation}`,options
    );
  }


export const getOperationsGetOperationQueryKey = (operation: string,) => {
    return [`http://localhost:3333/operations/v1/operations/${operation}`] as const;
    }

    
export const getOperationsGetOperationQueryOptions = <TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(operation: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOperationsGetOperationQueryKey(operation);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof operationsGetOperation>>> = ({ signal }) => operationsGetOperation(operation, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(operation), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OperationsGetOperationQueryResult = NonNullable<Awaited<ReturnType<typeof operationsGetOperation>>>
export type OperationsGetOperationQueryError = AxiosError<Status>


export function useOperationsGetOperation<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof operationsGetOperation>>,
          TError,
          Awaited<ReturnType<typeof operationsGetOperation>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsGetOperation<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof operationsGetOperation>>,
          TError,
          Awaited<ReturnType<typeof operationsGetOperation>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsGetOperation<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOperationsGetOperation<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOperationsGetOperationQueryOptions(operation,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getOperationsGetOperationSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(operation: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOperationsGetOperationQueryKey(operation);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof operationsGetOperation>>> = ({ signal }) => operationsGetOperation(operation, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OperationsGetOperationSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof operationsGetOperation>>>
export type OperationsGetOperationSuspenseQueryError = AxiosError<Status>


export function useOperationsGetOperationSuspense<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsGetOperationSuspense<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOperationsGetOperationSuspense<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOperationsGetOperationSuspense<TData = Awaited<ReturnType<typeof operationsGetOperation>>, TError = AxiosError<Status>>(
 operation: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof operationsGetOperation>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOperationsGetOperationSuspenseQueryOptions(operation,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Deletes a long-running operation. This method indicates that the client is
 no longer interested in the operation result. It does not cancel the
 operation. If the server doesn't support this method, it returns
 `google.rpc.Code.UNIMPLEMENTED`.
 */
export const operationsDeleteOperation = (
    operation: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CosmicapisProtoEmpty>> => {
    
    
    return axios.delete(
      `http://localhost:3333/operations/v1/operations/${operation}`,options
    );
  }



export const getOperationsDeleteOperationMutationOptions = <TError = AxiosError<Status>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof operationsDeleteOperation>>, TError,{operation: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof operationsDeleteOperation>>, TError,{operation: string}, TContext> => {

const mutationKey = ['operationsDeleteOperation'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof operationsDeleteOperation>>, {operation: string}> = (props) => {
          const {operation} = props ?? {};

          return  operationsDeleteOperation(operation,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OperationsDeleteOperationMutationResult = NonNullable<Awaited<ReturnType<typeof operationsDeleteOperation>>>
    
    export type OperationsDeleteOperationMutationError = AxiosError<Status>

    export const useOperationsDeleteOperation = <TError = AxiosError<Status>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof operationsDeleteOperation>>, TError,{operation: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof operationsDeleteOperation>>,
        TError,
        {operation: string},
        TContext
      > => {

      const mutationOptions = getOperationsDeleteOperationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Starts asynchronous cancellation on a long-running operation.  The server
 makes a best effort to cancel the operation, but success is not
 guaranteed.  If the server doesn't support this method, it returns
 `google.rpc.Code.UNIMPLEMENTED`.  Clients can use
 [Operations.GetOperation][google.longrunning.Operations.GetOperation] or
 other methods to check whether the cancellation succeeded or whether the
 operation completed despite cancellation. On successful cancellation,
 the operation is not deleted; instead, it becomes an operation with
 an [Operation.error][google.longrunning.Operation.error] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
 corresponding to `Code.CANCELLED`.
 */
export const operationsCancelOperation = (
    operation: string,
    cancelOperationRequest: CancelOperationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Status>> => {
    
    
    return axios.post(
      `http://localhost:3333/operations/v1/operations/${operation}:cancel`,
      cancelOperationRequest,options
    );
  }



export const getOperationsCancelOperationMutationOptions = <TError = AxiosError<Status>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof operationsCancelOperation>>, TError,{operation: string;data: CancelOperationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof operationsCancelOperation>>, TError,{operation: string;data: CancelOperationRequest}, TContext> => {

const mutationKey = ['operationsCancelOperation'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof operationsCancelOperation>>, {operation: string;data: CancelOperationRequest}> = (props) => {
          const {operation,data} = props ?? {};

          return  operationsCancelOperation(operation,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OperationsCancelOperationMutationResult = NonNullable<Awaited<ReturnType<typeof operationsCancelOperation>>>
    export type OperationsCancelOperationMutationBody = CancelOperationRequest
    export type OperationsCancelOperationMutationError = AxiosError<Status>

    export const useOperationsCancelOperation = <TError = AxiosError<Status>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof operationsCancelOperation>>, TError,{operation: string;data: CancelOperationRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof operationsCancelOperation>>,
        TError,
        {operation: string;data: CancelOperationRequest},
        TContext
      > => {

      const mutationOptions = getOperationsCancelOperationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
